# javaScript 面试题

## 1. 防抖

单位时间内，频繁触发事件，只执行最后一次。
比如点击按钮，2 秒后调用函数，结果在 1.5 秒的时候又点了，则会重新计算 2 秒后在调用函数。

- ### 1.1 应用场景

- 搜索框搜索输入。只需用户最后一次输入完，再发送请求
- 窗口大小 Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。

## 2. 节流

单位时间内，频繁触发事件，只执行一次

- ### 2.2 应用场景

- 拖拽功能。每隔一段时间计算鼠标位置，防止重复渲染。
- 监听滚动事件。每隔一段时间计算滚动位置，防止重复渲染。

## 单例模式

单例模式（Singleton Pattern） 是 JavaScript 中一种常见的设计模式，其核心思想是：确保一个类只有一个实例，并提供一个全局访问点来获取这个唯一的实例。它的主要目的是避免重复创建对象，节约资源，并确保全局共享同一份状态或功能。

## 3. Promise

Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件更合理和强大。

- ### 3.1 特点

  - 对象和函数的自定义，都具备 then 方法。
  - 链式调用。then 方法返回 promise 对象，可以继续调用 then 方法。
  - 状态改变。Promise 对象有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种
  - 状态改变后，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要
    这两种情况发生，状态就凝固了，不会再变了。

- ### 3.2 缺点

  - 无法取消 Promise，一旦新建它就会立即执行，无法中途取消。
  - 如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。
  - 当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

- ### 3.3 状态转换

  - pending -> fulfilled
  - pending -> rejected
  - fulfilled -> pending
  - rejected -> pending

- ### 3.4 如何实现异步

## 4. Ajax

Ajax 是异步 JavaScript 和 XML 的缩写。

- ### 特点

  - 异步与同步：Ajax 是一种异步通信技术。
  - 局部刷新：Ajax 不需要刷新整个页面，只需要刷新页面中的局部数据。

- #### 缺点

  - 不利于搜索引擎优化。
  - 不利于程序调试。
  - 不利于程序的缓存。

- #### 优点

  - 减轻服务器的负担，节省带宽。
  - Ajax 可以实现异步通信，这样用户就可以与服务器进行异步交互了。
  - Ajax 可以实现局部刷新，这样用户就可以实现不刷新整个页面的情况下，实现一些局部刷新了。
  - Ajax 可以实现程序调试，这样用户就可以在浏览器中查看程序报错。
  - Ajax 可以实现程序的缓存，这样用户就可以在浏览器中查看程序报错。

- #### Ajax 请求过程

  - 创建 XMLHttpRequest 对象。
  - 创建新的 HTTP 请求。
  - 设置请求回调函数。
  - 发送 HTTP 请求。
  - 处理服务器响应。

- #### 创建 XMLHttpRequest 对象

  ```js
  var xhr = new XMLHttpRequest();
  ```

- #### 创建新的 HTTP 请求

  ```js
  xhr.open('GET', 'http://www.example.com/example.php');
  ```

- #### 设置请求回调函数

  ```js
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4 && xhr.status === 200) {
      // 请求已完成，且响应已就绪
      console.log(xhr.responseText); // 处理服务器返回的数据
      // 在这里可以调用其他函数来处理数据
    }
  };
  ```

- #### 设置请求失败时的回调函数（可选）

  ```js
  xhr.onerror = function () {
    console.error('请求失败');
  };
  ```

- #### 发送请求

  ```
  xhr.send();
  ```

## 5. 闭包

### 声明在一个函数中的函数，叫做闭包函数

- #### a.闭包的核心特点

  **1. 函数嵌套函数：** 闭包通常发生在函数内部定义另一个函数时

  **2.内部函数可以访问外部函数的变量和参数：** 即使外部函数已经执行完毕

  **3. 变量不会被垃圾回收机制回收：** 因为内部函数保持着对外部函数变量的引用

- #### b.为什么需要闭包？

  **封装私有变量：** 创建只能通过特定方法访问的私有变量  
  **保持变量状态：** 在函数执行完毕后，仍然保持变量的状态  
  **模块化开发：** 实现模块模式，避免全局污染

- #### c.如何避免过度使用闭包导致的内存问题？

  **限制闭包的范围**

  - 最小化、及时释放

  **谨慎使用监听器**

  - 注意绑定、一次性监听器

  **dom 节点释放**  
  **清理定时器**

## 6 .null 和 undefined 的区别

- null 和 undefined 的区别：

  - null object 类型，代表“空值”，表示一个空对象引用，而 undefined 是 undefined 类型，表示未定义。

  ```javascript
  console.log(null == undefined); // true
  console.log(null === undefined); // false
  ```

## 7. 事件委托

- ### 什么是事件委托

  - 事件委托是利用事件冒泡的原理，把子元素的点击事件委托给父元素，通过判断事件源元素是否为需要设置的元素，来执行相应的函数。
  - 事件委托的原理是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。
  - 事件委托的优点是：
    1.  减少事件处理程序的注册，提高性能。
    2.  可以动态添加子元素，不需要再为子元素绑定事件。
    3.  可以使用事件委托的子元素，在 DOM 树中是静态的，不会动态添加子元素。
    4.  可以使用事件委托，处理动态添加的 HTML 元素的事件。
    5.  可以使用事件委托，处理跨浏览器的事件。

## 8. 跨域

- ### 什么是跨域

- 跨域是指从一个域上加载的脚本，试图去访问另一个域的属性或方法。
- 跨域的常见形式包括：
  1.  img 标签的 src 属性
  2.  a 标签的 href 属性
  3.  form 表单的 action 属性
  4.  script 标签的 src 属性
  5.  iframe 的 src 属性
  6.  link 和 script 的 src 属性
  7.  location 的 href 属性
- 跨域的解决方案：
  1.  JSONP
  2.  CORS
  3.  postMessage
  4.  WebSocket
  5.  代理
  6.  nginx 反向代理
  7.  NodeJS 中间件代理

## 8. 原型和原型链

- ### 原型

在 JS 中，每个函数在被创建的时候就会有一个 prototype 属性，这个属性是一个指针，指向一个对象，而这个对象就是这个函数的原型对象（也就是原型），它是用来共享所有实例的属性和方法的地方，所以原型其实就是函数的伴生体（与生俱来的）

- ### 原型链

原型链，简单理解就是原型组成的链。当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的**proto**隐式原型上查找，即它的构造函数的 prototype，如果还没有找到就会再在构造函数的 prototype 的**proto**中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。

- ### 原型链的应用场景

  - 面向对象编程中的继承：通过原型链实现子类对父类的继承，可以复用父类的属性和方法。
  - DOM 操作：在 JavaScript 中，DOM 元素也是对象，它们也通过原型链继承了 Element.prototype、Node.prototype 和 Object.prototype 上的方法和属性，这使得操作 DOM 变得简单高效。
  - 封装工具类：可以将一些常用的方法封装在原型链上，通过原型链的共享机制，使得这些方法可以被多个对象所共享和使用。

## 9. 深拷贝和浅拷贝

- ### 浅拷贝

> 浅拷贝只复制对象的第一层属性，如果对象的属性值是基本数据类型（如 String、Number），则直接复制值；如果属性值是引用数据类型（如 Object、Array），则复制引用地址，即复制后的对象与原始对象共享这部分数据的引用。因此，对于引用数据类型的属性，修改其中一个对象会影响另一个对象。  
> JavaScript 中常见的浅拷贝方法有：  
> Object.assign() 方法  
> 扩展运算符（...）  
> Array.prototype.slice()（对于数组）  
> Array.prototype.concat()（对于数组）

```javaScript
let original = { a: 1, b: { c: 2 } };
let copy = Object.assign({}, original);

// 修改原始对象的非引用类型属性
original.a = 10;
console.log(copy.a); // 1，说明非引用类型属性被独立复制

 // 修改原始对象的引用类型属性
original.b.c = 20;
console.log(copy.b.c); // 20，说明引用类型属性共享引用
```

- ### 深拷贝

  深拷贝会递归复制对象中的所有层级，确保所有级别的数据都是独立的，修改其中一个对象不会影响另一个对象。
  JavaScript 中没有内置的深拷贝方法，但可以通过一些技巧来实现，如：
  JSON.parse(JSON.stringify(object)) 方法（有局限性，比如无法复制函数、undefined、循环引用等）
  手动递归复制
  使用库函数，如 Lodash 的\_.cloneDeep()

  ```JavaScript
  let original = { a: 1, b: { c: 2 } };
  let copy = JSON.parse(JSON.stringify(original));

  // 修改原始对象
  original.a = 10;
  original.b.c = 20;

  console.log(copy.a); // 1
  console.log(copy.b.c); // 2，说明深拷贝后对象完全独立
  ```

  注意事项
  JSON 方法深拷贝的局限性：该方法不能正确处理函数、undefined、Symbol、循环引用等复杂情况。
  性能问题：深拷贝比浅拷贝更消耗资源，特别是在处理大型对象或包含大量嵌套对象时。
  选择方法：根据实际需求和对象结构选择合适的拷贝方法。对于简单的数据结构，浅拷贝可能就足够了；而对于复杂的、需要保持完全独立的数据结构，深拷贝是必需的。
