# javaScript面试题

## 1. 防抖

单位时间内，频繁触发事件，只执行最后一次。
比如点击按钮，2 秒后调用函数，结果在 1.5 秒的时候又点了，则会重新计算 2 秒后在调用函数。

- ### 1.1 应用场景

- 搜索框搜索输入。只需用户最后一次输入完，再发送请求
- 窗口大小 Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。

## 2. 节流

单位时间内，频繁触发事件，只执行一次

- ### 2.2 应用场景

- 拖拽功能。每隔一段时间计算鼠标位置，防止重复渲染。
- 监听滚动事件。每隔一段时间计算滚动位置，防止重复渲染。

## 单例模式

 单例模式（Singleton Pattern） 是 JavaScript 中一种常见的设计模式，其核心思想是：确保一个类只有一个实例，并提供一个全局访问点来获取这个唯一的实例。它的主要目的是避免重复创建对象，节约资源，并确保全局共享同一份状态或功能。

## 3. Promise

Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件更合理和强大。

- ### 3.1 特点

  - 对象和函数的自定义，都具备 then 方法。
  - 链式调用。then 方法返回 promise 对象，可以继续调用 then 方法。
  - 状态改变。Promise 对象有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种
  - 状态改变后，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要
    这两种情况发生，状态就凝固了，不会再变了。

- ### 3.2 缺点

  - 无法取消 Promise，一旦新建它就会立即执行，无法中途取消。
  - 如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。
  - 当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

- ### 3.3 状态转换

  - pending -> fulfilled
  - pending -> rejected
  - fulfilled -> pending
  - rejected -> pending

- ### 3.4 如何实现异步

## 4. Ajax

Ajax 是异步 JavaScript 和 XML 的缩写。

- ### 特点

  - 异步与同步：Ajax 是一种异步通信技术。
  - 局部刷新：Ajax 不需要刷新整个页面，只需要刷新页面中的局部数据。

- #### 缺点

  - 不利于搜索引擎优化。
  - 不利于程序调试。
  - 不利于程序的缓存。

- #### 优点

  - 减轻服务器的负担，节省带宽。
  - Ajax 可以实现异步通信，这样用户就可以与服务器进行异步交互了。
  - Ajax 可以实现局部刷新，这样用户就可以实现不刷新整个页面的情况下，实现一些局部刷新了。
  - Ajax 可以实现程序调试，这样用户就可以在浏览器中查看程序报错。
  - Ajax 可以实现程序的缓存，这样用户就可以在浏览器中查看程序报错。

- #### Ajax 请求过程

  - 创建 XMLHttpRequest 对象。
  - 创建新的 HTTP 请求。
  - 设置请求回调函数。
  - 发送 HTTP 请求。
  - 处理服务器响应。

- #### 创建 XMLHttpRequest 对象

  ```js
  var xhr = new XMLHttpRequest();
  ```

- #### 创建新的 HTTP 请求

  ```js
  xhr.open('GET', 'http://www.example.com/example.php');
  ```

- #### 设置请求回调函数

  ```js
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4 && xhr.status === 200) {
      // 请求已完成，且响应已就绪
      console.log(xhr.responseText); // 处理服务器返回的数据
      // 在这里可以调用其他函数来处理数据
    }
  };
  ```

- #### 设置请求失败时的回调函数（可选）

  ```js
  xhr.onerror = function () {
    console.error('请求失败');
  };
  ```

- #### 发送请求

  ```
  xhr.send();
  ```

## 5. 闭包

- ### 闭包函数：声明在一个函数中的函数，叫做闭包函数

- ### 闭包：内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后

- 闭包就是能够读取其他函数内部变量的函数

- #### 闭包存在意义

  - 1. 数据封装和隐私保护：
       闭包允许你将函数以及该函数的词法环境（即该函数被创建时的作用域）一起封装起来。这样，即使函数在外部作用域中被调用，它仍然可以访问并操作那些在外部作用域中定义的变量。这种特性可以用来隐藏或封装数据，只通过特定的函数接口来访问这些数据，从而实现了数据的封装和隐私保护。
  - 2. 创建私有变量：
       在 JavaScript 中，由于函数作用域的存在，闭包可以用来模拟私有变量。在函数内部定义的变量在外部是无法直接访问的，但是通过闭包，我们可以创建一个能够访问这些内部变量的外部函数。这样，我们就实现了类似于其他编程语言中类的私有成员的效果。
  - 3. 实现模块化和封装：
       利用闭包，我们可以创建模块化的代码，即将相关的代码和数据封装在一个函数内部，然后通过这个函数的返回值（通常是另一个函数或对象）来暴露必要的接口。这种方式有助于提高代码的可维护性和可重用性。
  - 4. 记忆功能：
       闭包使得函数能够记住并访问其作用域之外的变量，即使这些变量在作用域外部已经发生了变化或不再存在。这种记忆功能在某些场景下非常有用，比如实现缓存机制、模拟私有成员等。
  - 5. 创建高阶函数：
        高阶函数是至少满足下列一个条件的函数：接受一个或多个函数作为输入，或者输出一个函数。闭包是实现高阶函数的重要手段之一，因为闭包允许我们将函数作为参数传递给其他函数，并在这些函数内部创建新的函数来访问和操作外部作用域的变量。
  - 6. 模拟块级作用域：
       在 ES6 之前，JavaScript 没有块级作用域的概念（只有函数作用域和全局作用域）。通过闭包，我们可以模拟出块级作用域的效果，即限制变量的作用域范围，避免变量污染全局作用域或不必要的外部访问。

- #### 闭包的好处

  - 可以读取其他函数的内部变量
  - 将变量始终保存在内存中
  - 可以封装对象的私有属性和方法

## 6 .null 和 undefined 的区别

- null 和 undefined 的区别：
  - null object 类型，代表“空值”，表示一个空对象引用，而 undefined 是 undefined 类型，表示未定义。

  ```javascript
  console.log(null == undefined); // true
  console.log(null === undefined); // false
  ```

## 7. 事件委托

- ### 什么是事件委托

  - 事件委托是利用事件冒泡的原理，把子元素的点击事件委托给父元素，通过判断事件源元素是否为需要设置的元素，来执行相应的函数。
  - 事件委托的原理是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。
  - 事件委托的优点是：
     1. 减少事件处理程序的注册，提高性能。
     2. 可以动态添加子元素，不需要再为子元素绑定事件。
     3. 可以使用事件委托的子元素，在 DOM 树中是静态的，不会动态添加子元素。
     4. 可以使用事件委托，处理动态添加的 HTML 元素的事件。
     5. 可以使用事件委托，处理跨浏览器的事件。

## 8. 跨域

- ### 什么是跨域

- 跨域是指从一个域上加载的脚本，试图去访问另一个域的属性或方法。
- 跨域的常见形式包括：
   1. img 标签的 src 属性
   2. a 标签的 href 属性
   3. form 表单的 action 属性
   4. script 标签的 src 属性
   5. iframe 的 src 属性
   6. link 和 script 的 src 属性
   7. location 的 href 属性
- 跨域的解决方案：
   1. JSONP
   2. CORS
   3. postMessage
   4. WebSocket
   5. 代理
   6. nginx 反向代理
   7. NodeJS 中间件代理

## 8. 原型和原型链

- ### 原型

 在JS中，每个函数在被创建的时候就会有一个 prototype属性，这个属性是一个指针，指向一个对象，而这个对象就是这个函数的原型对象（也就是原型），它是用来共享所有实例的属性和方法的地方，所以原型其实就是函数的伴生体（与生俱来的）

- ### 原型链

 原型链，简单理解就是原型组成的链。当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。

- ### 原型链的应用场景

  - 面向对象编程中的继承：通过原型链实现子类对父类的继承，可以复用父类的属性和方法。
  - DOM 操作：在 JavaScript 中，DOM 元素也是对象，它们也通过原型链继承了 Element.prototype、Node.prototype 和 Object.prototype 上的方法和属性，这使得操作 DOM 变得简单高效。
  - 封装工具类：可以将一些常用的方法封装在原型链上，通过原型链的共享机制，使得这些方法可以被多个对象所共享和使用。

## 9. 深拷贝和浅拷贝

- ### 浅拷贝

> 浅拷贝只复制对象的第一层属性，如果对象的属性值是基本数据类型（如 String、Number），则直接复制值；如果属性值是引用数据类型（如 Object、Array），则复制引用地址，即复制后的对象与原始对象共享这部分数据的引用。因此，对于引用数据类型的属性，修改其中一个对象会影响另一个对象。  
> JavaScript 中常见的浅拷贝方法有：  
> Object.assign() 方法  
> 扩展运算符（...）  
> Array.prototype.slice()（对于数组）  
> Array.prototype.concat()（对于数组）

```javaScript
let original = { a: 1, b: { c: 2 } };
let copy = Object.assign({}, original);

// 修改原始对象的非引用类型属性
original.a = 10;
console.log(copy.a); // 1，说明非引用类型属性被独立复制

 // 修改原始对象的引用类型属性
original.b.c = 20;
console.log(copy.b.c); // 20，说明引用类型属性共享引用
```

- ### 深拷贝

  深拷贝会递归复制对象中的所有层级，确保所有级别的数据都是独立的，修改其中一个对象不会影响另一个对象。
  JavaScript 中没有内置的深拷贝方法，但可以通过一些技巧来实现，如：
  JSON.parse(JSON.stringify(object)) 方法（有局限性，比如无法复制函数、undefined、循环引用等）
  手动递归复制
  使用库函数，如 Lodash 的\_.cloneDeep()

  ```JavaScript
  let original = { a: 1, b: { c: 2 } };
  let copy = JSON.parse(JSON.stringify(original));

  // 修改原始对象
  original.a = 10;
  original.b.c = 20;

  console.log(copy.a); // 1
  console.log(copy.b.c); // 2，说明深拷贝后对象完全独立
  ```

  注意事项
  JSON 方法深拷贝的局限性：该方法不能正确处理函数、undefined、Symbol、循环引用等复杂情况。
  性能问题：深拷贝比浅拷贝更消耗资源，特别是在处理大型对象或包含大量嵌套对象时。
  选择方法：根据实际需求和对象结构选择合适的拷贝方法。对于简单的数据结构，浅拷贝可能就足够了；而对于复杂的、需要保持完全独立的数据结构，深拷贝是必需的。
