## 1. 防抖

单位时间内，频繁触发事件，只执行最后一次。
比如点击按钮，2 秒后调用函数，结果在 1.5 秒的时候又点了，则会重新计算 2 秒后在调用函数。

- #### 1.1 应用场景：

- 搜索框搜索输入。只需用户最后一次输入完，再发送请求
- 窗口大小 Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。

## 2. 节流

单位时间内，频繁触发事件，只执行一次

- #### 2.2 应用场景：

- 拖拽功能。每隔一段时间计算鼠标位置，防止重复渲染。
- 监听滚动事件。每隔一段时间计算滚动位置，防止重复渲染。

## 3. Promise

Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件更合理和强大。

- #### 3.1 特点：

  - 对象和函数的自定义，都具备 then 方法。
  - 链式调用。then 方法返回 promise 对象，可以继续调用 then 方法。
  - 状态改变。Promise 对象有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种
  - 状态改变后，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要
    这两种情况发生，状态就凝固了，不会再变了。

- #### 3.2 缺点：

  - 无法取消 Promise，一旦新建它就会立即执行，无法中途取消。
  - 如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。
  - 当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

- #### 3.3 状态转换：

  - pending -> fulfilled
  - pending -> rejected
  - fulfilled -> pending
  - rejected -> pending

## 4. Ajax

Ajax 是异步 JavaScript 和 XML 的缩写。

- #### 特点：

  - 异步与同步：Ajax 是一种异步通信技术。
  - 局部刷新：Ajax 不需要刷新整个页面，只需要刷新页面中的局部数据。

- #### 缺点：

  - 不利于搜索引擎优化。
  - 不利于程序调试。
  - 不利于程序的缓存。

- #### 优点：

  - 减轻服务器的负担，节省带宽。
  - Ajax 可以实现异步通信，这样用户就可以与服务器进行异步交互了。
  - Ajax 可以实现局部刷新，这样用户就可以实现不刷新整个页面的情况下，实现一些局部刷新了。
  - Ajax 可以实现程序调试，这样用户就可以在浏览器中查看程序报错。
  - Ajax 可以实现程序的缓存，这样用户就可以在浏览器中查看程序报错。

- #### Ajax 请求过程：

  - 创建 XMLHttpRequest 对象。
  - 创建新的 HTTP 请求。
  - 设置请求回调函数。
  - 发送 HTTP 请求。
  - 处理服务器响应。

- #### 创建 XMLHttpRequest 对象：

  ```js
  var xhr = new XMLHttpRequest();
  ```

- #### 创建新的 HTTP 请求：

  ```js
  xhr.open('GET', 'http://www.example.com/example.php');
  ```

- #### 设置请求回调函数：

  ```js
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4 && xhr.status === 200) {
      // 请求已完成，且响应已就绪
      console.log(xhr.responseText); // 处理服务器返回的数据
      // 在这里可以调用其他函数来处理数据
    }
  };
  ```

- #### 设置请求失败时的回调函数（可选）

  ```js
  xhr.onerror = function () {
    console.error('请求失败');
  };
  ```

- #### 发送请求

  ```
  xhr.send();
  ```

## 5. 闭包

- #### 什么是闭包：
  - 闭包就是能够读取其他函数内部变量的函数
- #### 闭包存在意义:
  - 1. 数据封装和隐私保护：
       闭包允许你将函数以及该函数的词法环境（即该函数被创建时的作用域）一起封装起来。这样，即使函数在外部作用域中被调用，它仍然可以访问并操作那些在外部作用域中定义的变量。这种特性可以用来隐藏或封装数据，只通过特定的函数接口来访问这些数据，从而实现了数据的封装和隐私保护。
  - 2. 创建私有变量：
       在 JavaScript 中，由于函数作用域的存在，闭包可以用来模拟私有变量。在函数内部定义的变量在外部是无法直接访问的，但是通过闭包，我们可以创建一个能够访问这些内部变量的外部函数。这样，我们就实现了类似于其他编程语言中类的私有成员的效果。
  - 3. 实现模块化和封装：
       利用闭包，我们可以创建模块化的代码，即将相关的代码和数据封装在一个函数内部，然后通过这个函数的返回值（通常是另一个函数或对象）来暴露必要的接口。这种方式有助于提高代码的可维护性和可重用性。
  - 4. 记忆功能：
       闭包使得函数能够记住并访问其作用域之外的变量，即使这些变量在作用域外部已经发生了变化或不再存在。这种记忆功能在某些场景下非常有用，比如实现缓存机制、模拟私有成员等。
  - 5.  创建高阶函数：
        高阶函数是至少满足下列一个条件的函数：接受一个或多个函数作为输入，或者输出一个函数。闭包是实现高阶函数的重要手段之一，因为闭包允许我们将函数作为参数传递给其他函数，并在这些函数内部创建新的函数来访问和操作外部作用域的变量。
  - 6. 模拟块级作用域：
       在 ES6 之前，JavaScript 没有块级作用域的概念（只有函数作用域和全局作用域）。通过闭包，我们可以模拟出块级作用域的效果，即限制变量的作用域范围，避免变量污染全局作用域或不必要的外部访问。
- #### 闭包的好处
  - 可以读取其他函数的内部变量
  - 将变量始终保存在内存中
  - 可以封装对象的私有属性和方法

## 6. 事件委托

- #### 什么是事件委托：
  - 事件委托是利用事件冒泡的原理，把子元素的点击事件委托给父元素，通过判断事件源元素是否为需要设置的元素，来执行相应的函数。
  - 事件委托的原理是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。
  - 事件委托的优点是：
  - 1. 减少事件处理程序的注册，提高性能。
  - 2. 可以动态添加子元素，不需要再为子元素绑定事件。
  - 3. 可以使用事件委托的子元素，在 DOM 树中是静态的，不会动态添加子元素。
  - 4. 可以使用事件委托，处理动态添加的 HTML 元素的事件。
  - 5. 可以使用事件委托，处理跨浏览器的事件。

## 7. 跨域

- #### 什么是跨域：
- 跨域是指从一个域上加载的脚本，试图去访问另一个域的属性或方法。
- 跨域的常见形式包括：
  - 1. img 标签的 src 属性
  - 2. a 标签的 href 属性
  - 3. form 表单的 action 属性
  - 4. script 标签的 src 属性
  - 5. iframe 的 src 属性
  - 6. link 和 script 的 src 属性
  - 7. location 的 href 属性
- 跨域的解决方案：
  - 1. JSONP
  - 2. CORS
  - 3. postMessage
  - 4. WebSocket
  - 5. 代理
  - 6. nginx 反向代理
  - 7. NodeJS 中间件代理

## 8. 原型链

- 原型链的作用：
  - 实现继承：通过原型链，子类可以继承父类的属性和方法，这是面向对象编程中继承机制的实现方式之一。
  - 属性和方法查找：当访问一个对象的属性或方法时，如果该对象本身没有这个属性或方法，JavaScript 引擎会沿着原型链向上查找，直到找到匹配的属性或方法或达到原型链的末端。
  - 共享行为和属性：原型链使得对象之间能够共享行为和属性，提高了代码的重用性和可维护性。
- 原型链的特点
  - 就近原则：当访问一个对象的属性或方法时，JavaScript 会优先查找对象本身，如果没有找到，则沿着原型链向上查找，直到找到或到达原型链的末端。
  - 引用类型：原型链上共享的是引用类型的值，这意味着如果修改了原型链上某个引用类型的属性值，那么所有通过原型链访问到这个属性的对象都会受到影响。
  - 所有函数的默认原型都是 Object 的实例：在 JavaScript 中，每个函数都有一个默认的 prototype 属性，且这个属性指向的对象默认会继承自 Object.prototype。
- 原型链的应用场景
  - 面向对象编程中的继承：通过原型链实现子类对父类的继承，可以复用父类的属性和方法。
  - DOM 操作：在 JavaScript 中，DOM 元素也是对象，它们也通过原型链继承了 Element.prototype、Node.prototype 和 Object.prototype 上的方法和属性，这使得操作 DOM 变得简单高效。
  - 封装工具类：可以将一些常用的方法封装在原型链上，通过原型链的共享机制，使得这些方法可以被多个对象所共享和使用。

## 9. 深拷贝和浅拷贝

- #### 浅拷贝：

> 浅拷贝只复制对象的第一层属性，如果对象的属性值是基本数据类型（如 String、Number），则直接复制值；如果属性值是引用数据类型（如 Object、Array），则复制引用地址，即复制后的对象与原始对象共享这部分数据的引用。因此，对于引用数据类型的属性，修改其中一个对象会影响另一个对象。  
> JavaScript 中常见的浅拷贝方法有：  
> Object.assign() 方法  
> 扩展运算符（...）  
> Array.prototype.slice()（对于数组）  
> Array.prototype.concat()（对于数组）

```javaScript
let original = { a: 1, b: { c: 2 } };
let copy = Object.assign({}, original);

// 修改原始对象的非引用类型属性
original.a = 10;
console.log(copy.a); // 1，说明非引用类型属性被独立复制

 // 修改原始对象的引用类型属性
original.b.c = 20;
console.log(copy.b.c); // 20，说明引用类型属性共享引用
```

- 深拷贝：
  深拷贝会递归复制对象中的所有层级，确保所有级别的数据都是独立的，修改其中一个对象不会影响另一个对象。
  JavaScript 中没有内置的深拷贝方法，但可以通过一些技巧来实现，如：
  JSON.parse(JSON.stringify(object)) 方法（有局限性，比如无法复制函数、undefined、循环引用等）
  手动递归复制
  使用库函数，如 Lodash 的\_.cloneDeep()

  ```JavaScript
  let original = { a: 1, b: { c: 2 } };
  let copy = JSON.parse(JSON.stringify(original));

  // 修改原始对象
  original.a = 10;
  original.b.c = 20;

  console.log(copy.a); // 1
  console.log(copy.b.c); // 2，说明深拷贝后对象完全独立
  ```

  注意事项
  JSON 方法深拷贝的局限性：该方法不能正确处理函数、undefined、Symbol、循环引用等复杂情况。
  性能问题：深拷贝比浅拷贝更消耗资源，特别是在处理大型对象或包含大量嵌套对象时。
  选择方法：根据实际需求和对象结构选择合适的拷贝方法。对于简单的数据结构，浅拷贝可能就足够了；而对于复杂的、需要保持完全独立的数据结构，深拷贝是必需的。

## 10. Vue 中的 data 为什么是一个函数？

> 组件实例化的时候这个函数将会被调用，返回一个对象， 计算机会给这个对象分配一个内存地址，实例化几次就分配几个内存地址，他们的地址都不一样，所以每个组件中的数据不会相互干扰，改变其中一个组件的状态，其它组件不变。  
> 为了保证组件的独立性和可复用性，如果 data 是个函数的话，每复用一次组件就会返回新的 data，类似于给每个组件实例创 建一个私有的数据空间，保护各自的数据互不影响

## Vue2 和 Vue3 的区别

- 1.  性能提升
      > 更快的渲染速度：Vue 3 通过改进虚拟 DOM 的算法和底层架构，实现了更快的渲染速度和更低的内存使用率。在处理大量数据或复杂组件时，Vue 3 能够提供更流畅的用户体验。
           体积更小：通过 webpack 的 tree-shaking 功能，Vue 3 能够移除未使用的代码，从而减小最终打包的体积。这使得 Vue 3 在开发大型应用时更加高效。
- 2.  API 设计
      > 组合式 API（Composition API）：  
      > Vue 3 引入了一个新的 API——组合式 API，它提供了一种更灵活的方式来组织组件的逻辑。通过组合式 API，开发者可以将组件的功能拆分成更小的、可复用的函数（称为 composables），这有助于构建大型应用并保持代码的可维护性。与 Vue 2 的选项式 API 相比，组合式 API 使得代码更加简洁和易于理解。  
      > 生命周期钩子函数：  
      > Vue 3 中的生命周期钩子函数有所变化，如 beforeCreate 和 created 被 setup 函数替代，beforeMount 和 mounted 等钩子函数则需要在 onBeforeMount 和 onMounted 等函数中显式调用。此外，Vue 3 还增加了一些新的钩子函数，如 onRenderTracked 和 onRenderTriggered。

  - 3. 响应式系统

       > Proxy vs. Object.defineProperty：
       > Vue 3 的响应式系统是基于 ES6 的 Proxy API 实现的，而 Vue 2 则是基于 Object.defineProperty。Proxy API 能够提供更全面的属性监听（包括属性的添加、删除以及数组内部的变化），从而解决了 Vue 2 中响应式系统的一些限制。
       > 响应式 API 的改进：  
       > Vue 3 提供了一系列新的响应式 API，如 reactive、ref、computed 等，这些 API 使得开发者能够更灵活地处理响应式数据。

  - 4. TypeScript 支持
       > 更好的 TypeScript 集成：Vue 3 从一开始就把 TypeScript 作为一等公民来考虑，这意味着 Vue 3 与 TypeScript 的集成更加自然，为开发大型应用提供了更好的支持。Vue 3 的 API 和内部实现都充分考虑了 TypeScript 的类型安全特性。

- 5. 新特性
     > 多个根节点（Fragments）：  
     > Vue 3 支持组件拥有多个根节点，这在 Vue 2 中是不被支持的。这使得 Vue 3 的组件模板更加灵活。  
     > Teleport：  
     > Vue 3 引入了 Teleport 功能，它允许开发者将模板中的某个部分渲染到 DOM 中的其他位置，这在处理模态框、悬浮框等 UI 元素时非常有用。  
     > 自定义渲染器（createRenderer）：  
     > Vue 3 提供了 createRenderer 函数，允许开发者构建自定义渲染器，从而将 Vue 的开发模型扩展到其他平台（如 canvas）。

## Vue3 的生命周期有哪些

Vue 3 引入了 Composition API，这带来了编写组件的新方式，但同时也保留了 Options API。无论是使用哪种 API，Vue 3 的组件生命周期都是相似的，但有一些细微的差别和新增的钩子。

- #### setup()：
  这是 Vue3 中引入的组合式 API 的一个核心部分，它在组件创建之前执行，用于替代 Vue2 中的 beforeCreate 和 created 钩子。在 setup 中，可以定义响应式数据、计算属性、方法等，并且可以访问到组件的 props 和 context。
- #### Options API 生命周期钩子

  在 Options API 中，生命周期钩子被定义在组件的 `options` 对象中。以下是 Vue 3 中 Options API 的主要生命周期钩子：

  - 挂载（Mounting）
    - **beforeCreate**：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。
    - **created**：实例已经创建完成之后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，`$el` 属性目前不可见。
    - **beforeMount**：在挂载开始之前被调用：相关的 render 函数首次被调用。该钩子在服务器端渲染期间不被调用。
    - **mounted**：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。
  - 更新（Updating）
    - **beforeUpdate**：数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。
    - **updated**：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用这个钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。
  - 卸载（Unmounting）
    - **beforeUnmount**：在卸载组件实例之前调用。在这个阶段，实例仍然是完全可用的。
    - **unmounted**：Vue 实例卸载后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也都会被销毁。

- ### 激活与停用（对于 `<keep-alive>`）

- **activated**：被 keep-alive 缓存的组件激活时调用。
- **deactivated**：被 keep-alive 缓存的组件停用时调用。

- ### Composition API 生命周期钩子

  在 Composition API 中，生命周期钩子通过 `onXXX` 函数引入，这些函数可以在 `setup()` 函数内部使用。

  - **onBeforeMount**
  - **onMounted**
  - **onBeforeUpdate**
  - **onUpdated**
  - **onBeforeUnmount**
  - **onUnmounted**
  - **onActivated**
  - **onDeactivated**

  这些函数的使用方式与 Options API 中的生命周期钩子类似，但它们在 `setup()` 函数中通过导入 `onMounted` 等函数来使用，而不是直接定义在组件的 `options` 对象中。

  ```javascript
  import { onMounted } from 'vue';

  export default {
    setup() {
      onMounted(() => {
        console.log('组件已挂载');
      });
    },
  };
  ```

  ## Vuex 是什么

  - ##### vuex 是一个状态管理工具，集中式的管理所有组件的状态数据。统一的去管理组件，将组件的状态抽象为一个 store 文件，通过 commit 方法触发 mutation 里的函数来改变组件属性。

  - ##### 五个属性 state（存储） getters（获取） mutations（同步操作 /this.$store.commit(“方法名”,数据)/mapMutations） actions（异步操作 /this.$store.dispatch(“方法名”,数据)/mapActions） modules（放多个 vuex）

- #### Vuex 的优势
  **集中式存储管理：**  
  Vuex 将应用的所有组件的状态集中存储和管理，便于维护和调试。  
  **可预测的状态变化：**  
  Vuex 通过规定状态变化的流程（actions -> mutations -> state），保证了状态变化的可预测性。  
  **组件间通信：**  
  Vuex 提供了一种在组件间共享状态的机制，避免了组件间直接通信的复杂性。  
  **强大的开发工具支持：**  
  Vuex 集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。
