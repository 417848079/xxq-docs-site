## 1. jdk 和 jre 的区别

JDK（Java Development Kit，Java 开发工具包）和 JRE（Java Runtime Environment，Java 运行时环境）有以下主要区别：

#### 功能：

> JDK 包含了开发 Java 程序所需的工具和资源，不仅包括 JRE 中的运行时环境，还提供了编译器（javac）、调试工具（如 jdb）、文档生成工具（javadoc）等，用于编写、编译、调试和运行 Java 应用程序。  
>  JRE 则主要用于运行 Java 程序，它包含了 Java 虚拟机（JVM）、核心类库和支持文件，确保 Java 程序能够在计算机上正常运行，但不包含开发工具。

#### 用途：

> 如果您要开发 Java 应用程序、小程序或 Web 应用，就需要安装 JDK。  
>  如果您只是想运行已有的 Java 应用程序，而不需要进行开发，那么安装 JRE 就足够了。  
>  例如，一个软件开发者在编写和测试新的 Java 代码时，会使用 JDK 。而普通用户在运行一个基于 Java 的游戏或办公软件时，计算机上只需安装 JRE 来支持程序的运行。
> 总的来说，JDK 适用于开发者，JRE 适用于普通用户运行 Java 程序。

## 1. 面向对象编程有哪些特征

面向对象编程（Object-Oriented Programming，OOP）具有以下主要特征：

- #### 1. 封装（Encapsulation）：
  将数据和操作数据的方法封装在一个类中，对外部隐藏类的内部实现细节，只通过公共的接口来访问类的成员。例如，将一个学生的信息（姓名、年龄、成绩等）和相关的操作（计算平均成绩、更新信息等）封装在 Student 类中。外部代码不能直接访问和修改类内部的私有数据，只能通过公共方法来进行操作。
- #### 2. 继承（Inheritance）：
  允许创建一个新类从已有的类中继承属性和方法，实现代码的复用和扩展。比如，创建一个 UndergraduateStudent 类继承自 Student 类，可以复用 Student 类中的通用属性和方法，并添加本科生特有的属性和方法。
- #### 3. 多态（Polymorphism）：
  分为两种类型，编译时多态（方法重载）和运行时多态（方法重写）。编译时多态是指在同一个类中，方法名相同但参数不同的多个方法。运行时多态是指子类可以重写父类的方法，在运行时根据对象的实际类型来决定调用哪个具体的方法。例如，有一个父类 Shape 和子类 Circle 、 Rectangle ，它们都有 draw 方法，通过父类引用指向子类对象，调用 draw 方法时会执行子类中重写的方法。
- #### 4. 抽象（Abstraction）：
  提取出类或对象的本质特征，忽略非本质的细节。通过抽象类和接口来实现，强制子类实现某些方法或规定类的结构。比如定义一个抽象的 Animal 类，规定所有子类必须实现 eat 和 move 方法，但不给出具体实现。
  这些特征使得面向对象编程更加模块化、可复用、可扩展和易于维护，能够更好地模拟现实世界中的复杂系统。

## 线程和进程的区别

- 进程：  
  是系统进行资源分配和调度的一个独立单元，它是应用程序执行的实例。进程拥有独立的内存空间和系统资源，每个进程都有各自独立的程序计数器、堆栈和其他系统资源。
- 线程：  
  是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的独立运行的基本单位。线程也被称为轻量级进程。一个进程可以拥有多个线程，这些线程共享进程的资源（如内存、文件句柄等）。

## 线程死锁

在 Java 线程中，死锁是指两个或两个以上的线程在执行过程中，因竞争资源或彼此通信不当而造成的一种阻塞现象，若无外力作用，这些线程都将无法继续执行下去。死锁的发生必须具备以下四个必要条件：

- 互斥条件（Mutual Exclusion）：  
  至少有一个资源必须处于非共享模式，即一次只能被一个线程使用。当一个线程占用某个资源时，其他线程必须等待，直到该资源被释放。
- 请求与保持条件（Hold and Wait）：  
  一个线程已经持有至少一个资源，同时又提出新的资源请求，而该资源已被其他线程占有，此时请求线程被阻塞，但又对自己已获得的资源保持不放。即线程至少已经保持了一个资源，并等待获取其他线程持有的资源。
- 不可剥夺条件（No Preemption）：  
  已经分配给一个线程的资源不能被强制剥夺，只有该线程使用完毕后才能释放资源。资源只能由占有它的线程自愿释放，而不能被其他线程抢占。
- 循环等待条件（Circular Wait）：  
   存在一个线程资源的循环链，链中的每个线程都在等待下一个线程所持有的资源，形成一个头尾相接的环形等待链。例如，线程 A 等待线程 B 的资源，线程 B 等待线程 C 的资源，而线程 C 又等待线程 A 的资源。

**这四个条件必须同时满足，才会发生死锁。为了预防或解决死锁问题，可以采取以下策略：**

- 预防死锁：  
  通过破坏死锁产生的四个条件中的一个或多个来预防死锁的发生。例如，确保所有线程以相同的顺序请求资源，从而避免循环等待。
- 避免死锁：  
  在资源的动态分配过程中，使用某种方法去防止系统进入不安全状态，从而避免发生死锁。例如，使用银行家算法来动态地检查资源分配状态，确保系统始终处于安全状态。
- 检测死锁：  
  允许系统在运行过程中发生死锁，但通过设置检测机构及时检测死锁的发生，并确定与死锁相关的线程和资源。
- 解除死锁：  
  当检测到死锁时，通过撤销或挂起一些线程来回收资源，并将这些资源分配给处于阻塞状态的线程，从而解除死锁。
  在实际编程中，合理设计资源的获取和释放顺序，避免嵌套的同步代码块，以及使用正确的并发控制策略和工具（如 synchronized 关键字、Lock 接口和 Condition 接口等），都可以有效地减少死锁的风险。

## synchronized 与 Lock 对比

- **synchronized 与 Lock 是 Java 中用于实现线程同步的两种不同机制，它们在多个方面存在显著的差异。以下是对这两种机制的详细对比：**

  **1. 性质与实现方式**
  synchronized：是 Java 的一个关键字，它可以直接应用于方法或代码块上，使用起来相对简洁。synchronized 在内部实现上，JVM 会为其维护一个锁计数器和一个指向持有锁的线程的指针。
  Lock：是 java.util.concurrent.locks 包下的一个接口，常用的实现类有 ReentrantLock 等。Lock 的使用需要显式地获取锁和释放锁，这通常通过调用 lock()和 unlock()方法来实现。
